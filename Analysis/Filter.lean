import Analysis.Set.Function

/--
  A filter on `Î±` is a set of sets of `Î±` containing `Î±` itself, closed under 
  supersets and intersection.
  NB. This definition of filters does not require `âˆ… âˆ‰ sets`. This is done so 
  we can create a lattice structure. `âˆ… âˆ‰ sets` should be included as a 
  seperate proposition in lemmas.
-/
structure Filter (Î± : Type u) where
  sets                   : Set (Set Î±)
  univ_sets              : Set.univ âˆˆ sets
  sets_of_superset {x y} : x âˆˆ sets â†’ x âŠ† y â†’ y âˆˆ sets
  inter_sets       {x y} : x âˆˆ sets â†’ y âˆˆ sets â†’ x âˆ© y âˆˆ sets

-- I'm going to follow 
-- https://web.archive.org/web/20071009170540/http://www.efnet-math.org/~david/mathematics/filters.pdf

-- First, we will find a way to generate filters for any given set of sets of Î±
-- To achieve this, we consider that the intersection of a collection of filters 
-- is also a filter, so therefore, a filter can be generated form a set of sets 
-- by taking the intersection of all filters containing this set, i.e. if `S` is 
-- type `set (set Î±)`, then the filter generated by `S` is 
-- â‹‚ { F : filter Î± | S âŠ† F.sets }

namespace Filter

open Set

instance : Coe (Filter Î±) (Set (Set Î±)) := âŸ¨Î» F => F.setsâŸ©

instance : Mem (Set Î±) (Filter Î±) := âŸ¨Î» x F => x âˆˆ (F : Set (Set Î±))âŸ©

instance : HasLessEq (Filter Î±) := âŸ¨Î» F G => (G : Set (Set Î±)) â‰¤ FâŸ©

/-! ### Basics -/

theorem eq {F G : Filter Î±} (h : F.sets = G.sets) : F = G := by
  cases F; cases G; subst h; rfl
  
theorem eqIff {F G : Filter Î±} : F = G â†” F.sets = G.sets := 
Iff.intro (Î» h => h â–¸ rfl) eq

theorem ext {F G : Filter Î±} (h : âˆ€ s, s âˆˆ F â†” s âˆˆ G) : F = G := 
  eq <| Set.ext h

/-- The intersection of a collection of filters is a filter. -/
def Inf (ğ’ : Set (Filter Î±)) : Filter Î± :=
{ sets := â‹‚ F âˆˆ ğ’, F
  univ_sets := Î» F hF => F.univ_sets
  sets_of_superset := Î» hx hxy F hF => F.sets_of_superset (hx F hF) hxy
  inter_sets := Î» hx hy F hF => F.inter_sets (hx F hF) (hy F hF) }

-- With that we can now define the filter generated by an arbitary set of sets 

/-- The filter generated from `S`, a set of sets of `Î±` is the Inf of all filters 
  containing `S` -/
def generatedFrom (S : Set (Set Î±)) : Filter Î± := 
  Inf { F : Filter Î± | S âŠ† F }

-- The method above generates the smallest filter that contains `S : set (set Î±)`
-- On the other hand, we can generate a filter using `s : set Î±` be letting the 
-- filter be all supersets of `s`, this is called `principal s`

/-- The principal filter of a set `s` is set set of all sets larger than `s`. -/
def principal (s : Set Î±) : Filter Î± := 
{ sets := { t | s âŠ† t }
  univ_sets := Subset.subsetUniv
  sets_of_superset := Î» hx hxy => Subset.trans hx hxy
  inter_sets := Î» hx hy => subsetInter hx hy }

prefix:100 "ğ“Ÿ " => principal

theorem selfMemPrincipal (s : Set Î±) : s âˆˆ ğ“Ÿ s := Subset.refl

variable {S : Set (Set Î±)}

theorem leGeneratedFrom : S âŠ† generatedFrom S := 
  Î» s hs F hF => hF _ hs

-- Straightaway, we see that if `âˆ… âˆˆ S`, then `generatedFrom S` is the powerset of `Î±` 
theorem generatedFromEmpty (hS : âˆ… âˆˆ S) (s : Set Î±) : s âˆˆ generatedFrom S := 
  (generatedFrom S).sets_of_superset (leGeneratedFrom _ hS) (Subset.empty s)

-- We don't want to consider filters with only the set `univ` and so, we 
-- introduce the `neBot` class

/-- The smallest filter is the filter containing only the set `univ`. -/
def bot : Filter Î± := 
{ sets := Î» s => univ = s
  univ_sets := rfl
  sets_of_superset := Î» hx hy => Subset.univSubsetIff.1 <| hx â–¸ hy
  inter_sets := Î» hx hy => Eq.symm <| hx â–¸ hy â–¸ interSelf }

/-- A filter is `neBot` if it is not equal to `Filter.bot`-/
class neBot (F : Filter Î±) where 
  ne_bot : F â‰  bot

/-- Let `F` be a `ne_bot` filter on `Î±`, `F` is an ultra filter if for all 
  `S : set Î±`, `S âˆˆ F` or `Sá¶œ âˆˆ F` -/
class Ultra (F : Filter Î±) where
  ne_bot : neBot F 
  mem_or_compl_mem {S : Set Î±} : S âˆˆ F âˆ¨ Sá¶œ âˆˆ F

-- The ultra filter theorem states that for all `F : filter Î±`, there exists 
-- some ultra filter `ğ•Œ`, `F âŠ† ğ•Œ`.

-- The proof of this follows from Zorn's lemma.
-- Let `F` be a filter on `Î±`, We have the filters of `Î±` that contain `F` form 
-- a poset. Let `ğ’` be a chain (a totaly ordered set) within this set, then by 
-- Zorn's lemma, `ğ’` has at least one maximum element. Thus, by checking this 
-- maximum element is indeed an ultra filter, we have found a ultra filter 
-- containing `F`.

-- We won't try proving it anytime soon
-- In Lean 3 mathlib its known as `exists_maximal_of_chains_bounded`

-- theorem existsUltraGe (F : Filter Î±) [neBot F] : 
--   âˆƒ (G : Filter Î±) [Ultra G], (F : Set (Set Î±)) âŠ† G := sorry

def map (f : Î± â†’ Î²) (F : Filter Î±) : Filter Î² := 
{ sets := preimage (preimage f) F
  univ_sets := F.univ_sets
  sets_of_superset := Î» hx hxy => F.sets_of_superset hx <| preimageMono f hxy
  inter_sets := Î» hx hy => F.inter_sets hx hy }

/-! ### Convergence -/

/-- A neighbourhood of `x` is the principal filter of the singleton set `{x}`-/
def neighbourhood (x : Î±) : Filter Î± := ğ“Ÿ {x}

notation:100 "ğ“ " x => ğ“Ÿ {x}

def eventually (p : Î± â†’ Prop) (F : Filter Î±) := p âˆˆ F

theorem eventually.ext {F G : Filter Î±} (h : âˆ€ p, eventually p F â†” eventually p G) : 
  F = G := 
Filter.ext h

theorem eventually.filter_mono {F G : Filter Î±} (h : F â‰¤ G) {p : Î± â†’ Prop}
  (hG : eventually p G) : eventually p F := h _ hG

/-- A filter `lâ‚` tendsto another filter `lâ‚‚` along some function `f` if the 
map of `lâ‚` along `f` is smaller than `lâ‚‚`. -/
def tendsto (f : Î± â†’ Î²) (lâ‚ : Filter Î±) (lâ‚‚ : Filter Î²) := lâ‚.map f â‰¤ lâ‚‚

theorem tendstoDef {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :
  tendsto f lâ‚ lâ‚‚ â†” âˆ€ s âˆˆ lâ‚‚, s.preimage f âˆˆ lâ‚ := Iff.rfl

theorem tendsto_iff_eventually {f : Î± â†’ Î²} {lâ‚ : Filter Î±} {lâ‚‚ : Filter Î²} :
  tendsto f lâ‚ lâ‚‚ â†” âˆ€ {p : Î² â†’ Prop} (hp : eventually p lâ‚‚), eventually (p âˆ˜ f) lâ‚ :=
Iff.rfl

#exit

-- Let X be a Hausdorff space
variables {X : Type*} [topological_space X]

/-- A filter `F` on a Hausdorff space `X` has at most one limit -/
theorem tendsto_unique {x y : X} {F : filter X} [H : ne_bot F] [t2_space X]
  (hFx : tendsto id F (nhds x)) 
  (hFy : tendsto id F (nhds y)) : x = y :=
begin
  by_contra hneq,
  rcases t2_space.t2 _ _ hneq with âŸ¨U, V, hU, hV, hxU, hyV, hdisjâŸ©,
  apply H, rw [â†empty_in_sets_eq_bot, â†hdisj],
  refine F.inter_sets _ _,
    { rw â†@preimage_id _ U,
      exact tendsto_def.1 hFx U (mem_nhds_sets hU hxU) },
    { rw â†@preimage_id _ V,
      exact tendsto_def.1 hFy V (mem_nhds_sets hV hyV) }
end

variables {Y : Type*} [topological_space Y]

@[reducible] def filter_image (f : X â†’ Y) (F : filter X) : filter Y := 
  generate $ (Î» s : set X, f '' s) '' F

-- We'll use mathlib's `generate` and `map` which are the same 
-- as the ones we've defined but there is more APIs to work with

/-- A filter `F : filter X` is said to converge to some `x : X` if `nhds x âŠ† F` -/
@[reducible] private def converge_to (F : filter X) (x : X) : Prop := 
  (nhds x : set (set X)) âŠ† F

-- This definition is equivalent to `tendsto id F (nhds x)`
private lemma converge_to_iff (F : filter X) (x : X) : 
  converge_to F x â†” tendsto id F (nhds x) :=
begin
  refine âŸ¨Î» h, tendsto_def.1 $ Î» s hs, _, Î» h, _âŸ©,
    { rw map_id, simpa using h hs },
    { simp_rw [tendsto_def, preimage_id] at h, exact h }
end

/-- The neighbourhood filter of `x` converges to `x` -/
lemma nhds_tendsto (x : X) : tendsto id (nhds x) (nhds x) := 
Î» U hU, by rwa map_id

lemma mem_filter_image_iff {f : X â†’ Y} {F : filter X} (V) : 
  V âˆˆ map f F â†” âˆƒ U âˆˆ F, f '' U âŠ† V :=
begin
  refine âŸ¨Î» h, âŸ¨_, h, image_preimage_subset _ _âŸ©, Î» h, _âŸ©,
    rcases h with âŸ¨U, hUâ‚€, hUâ‚âŸ©,
    rw mem_map,
    apply F.sets_of_superset hUâ‚€,
    intros u hu,
    rw mem_set_of_eq,
    apply hUâ‚, rw mem_image,
    exact âŸ¨u, hu, rflâŸ©    
end

lemma nhds_subset_filter_of_tendsto {x : X} {F : filter X} 
  (hF : tendsto id F (nhds x)) : (nhds x : set (set X)) âŠ† F :=
begin
  intros s hs,
  have := tendsto_def.1 hF _ hs,
  rwa preimage_id at this
end

/-- A map between topological spaces `f : X â†’ Y` is continuous at some `x : X` 
  if for all `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem continuous_of_filter_tendsto {x : X} (f : X â†’ Y)
  (hF : âˆ€ F : filter X, tendsto id F (nhds x) â†’ 
    tendsto id (map f F) (nhds (f x))) : continuous_at f x :=
Î» _ hU, tendsto_def.1 (hF _ $ nhds_tendsto x) _ hU

/-- If `f : X â†’ Y` is a continuous map between topological spaces, then for all 
  `F : filter X` that tends to `x`, `map F` tends to `f(x)` -/
theorem filter_tendsto_of_continuous {x : X} {F : filter X} (f : X â†’ Y) 
  (hf : continuous_at f x) (hF : tendsto id F (nhds x)) : 
  tendsto id (map f F) (nhds (f x)) := 
begin
  rw tendsto_def at *, intros U hU,
  exact nhds_subset_filter_of_tendsto hF (hf hU),
end

/-! ### Product Filters -/

/- Given two filters `F` and `G` on the topological spaces `X` and `Y` respectively, 
  we define the the product filter `F Ã— G` as a filter on the product space `X Ã— Y` 
  such that 
  `prod F G := F.comap prod.fst âŠ“ G.comap prod.snd`
  where `prod.fst = (a, b) â†¦ a`, `prod.snd = (a, b) â†¦ b` and 
  `(C : filter Î²).comap (f : Î± â†’ Î²)` is the filter generated by the set of preimages 
  of sets contained in `C`, i.e. `(C.comap f).sets = generate { fâ»Â¹(s) | s âˆˆ C }`. -/

-- We borrow the notation of product filters from mathlib
localized "infix ` Ã—á¶  `:60 := filter.prod" in filter

-- Write some theorems here maybe?
-- TODO : make the natural projection : filter (X Ã— Y) â†’ filter X


/-! ### Compactness -/

variables {C : Type*} [topological_space C] [compact_space C]
/- In mathlib a compact space is a topological space that satisfy the 
  `is_compact` proposition where 
  `def is_compact (s : set Î±) := âˆ€ â¦ƒfâ¦„ [ne_bot f], f â‰¤ ğ“Ÿ s â†’ âˆƒ a âˆˆ s, cluster_pt a f`
  (`cluset_pt a f` means a is a limit point of f) -/




end Filter